# 汇编语言

## 1. 简介

​	**汇编语言**是特定于计算机体系结构的计算机或其他可编程设备的低级编程语言，而大多数高级编程语言通常可跨多个系统移植。汇编语言通过称为NASM，MASM等汇编程序的实用程序转换为可执行的机器代码。

​	每台计算机都有一个微处理器，用于管理计算机的算术，逻辑和控制活动。每个处理器系列都有自己的指令集，用于处理各种操作，这些指令集称为"机器语言指令"。处理器仅能理解机器语言指令，而这些指令是1和0的字符串。但是机器语言过于晦涩难懂，无法在软件开发中使用，因此，低级的汇编语言是为特定的处理器家族设计的，该处理器以符号代码和更易理解的形式表示各种指令。

## 2. 汇编语言的优势

了解汇编语言会使人意识到：

- 程序如何与OS，处理器和BIOS交互；
- 内存和其他外部设备中数据的表示方式
- 指令如何访问和处理数据
- 处理器如何访问和执行指令
- 程序如何访问外部设备

使用汇编语言的其他优点是：

- 它需要更少的内存和执行时间
- 它可以更轻松地实现特定于硬件地复杂作业
- 适用于时间紧迫地工作
- 最适合编写**中断服务程序**和其他**内存驻留程序**

## 3. 基础背景知识

### 3.1 PC硬件的基本特征

​	PC的主要内部硬件由**处理器、存储器和寄存器**组成。寄存器是保存数据和地址的处理器组件。为了执行程序，系统将其从外部设备复制到内部存储器中，处理器执行程序指令。

### 3.2 寻址内存中的数据

​	处理器控制指令执行的过程称为**取指**-**解码**-**执行周期**。它由三个连续的步骤组成：

- 从内存中获取指令
- 解码或识别指令
- 执行指令

​	**小端存储**：处理器以相反的字节顺序存储数据，即低位字节存储在低内存地址中，高位字节存储在高内存地址中。因此，如果处理器将值0725H从寄存器传输到内存，它首先将25传输到较低的内存地址，然后将07存储到下一个内存地址。

​	当处理器从内存中获取数字数据到寄存器时，它会再次反转字节。内存地址有两种

- 绝对地址：具体位置的直接引用
- 段地址（或偏移量）：具有偏移值的内存段的起始地址

## 4. 汇编-基本语法

汇编程序可以分为三个部分：

- data部分
- bss部分
- text部分

### 4.1 data部分

​	**data**部分用于声明初始化数据或常量，该数据在运行时不会改变。可以声明各种常量值、文件名或缓冲区大小等。

​	声明数据部分的语法是

```assembly
section.data
```

### 4.2 bss部分

​	**bss**部分用于声明变量。语法：

```assembly
section.bss
```

### 4.3 text部分

​	**text**部分用于保存实际代码，此部分必须以声明global_start开头，它告诉内核程序执行的开始位置。语法：

```assembly
section.text
	glabal_start
_start:
```

### 4.4 注释

​	汇编语言注释以分号开头，它可以包含任何可打印字符。可以单独在一行也可以和代码在同一行。

### 4.5 汇编语言语句

​	汇编语言程序由三种类型的语句组成：

- 可执行指令或说明
- 汇编指令或伪操作
- 宏

​	**可执行指令**或简单的指令告诉处理器要做什么，每条指令由一个**操作码**组成。每条可执行指令生成一条机器语言指令。

​	汇编程序指令或伪操作告诉汇编程序有关编程的各个方面，不可执行，并不会生成机器语言指令。

​	宏基本上是一种文本替换机制。

​	**汇编语言语句的语法**

```assembly
[label] mnemonic [operands] [;comment]
```

​	基本指令由两部分组成：第一部分是要执行的指令名称（或助记符），第二部分是命令的操作数或参数。以下是一些典型的汇编语言语句示例：

```assembly
INC COUNT        ; Increment the memory variable COUNT

MOV TOTAL, 48    ; Transfer the value 48 in the 
                 ; memory variable TOTAL
					  
ADD AH, BH       ; Add the content of the 
                 ; BH register into the AH register
					  
AND MASK1, 128   ; Perform AND operation on the 
                 ; variable MASK1 and 128
					  
ADD MARKS, 10    ; Add 10 to the variable MARKS
MOV AL, 10       ; Transfer the value 10 to the AL register
```

### 4.6 汇编中的Hello World程序

以下汇编语言代码在屏幕上显示字符串"Hello World"

```assembly
section.text
	global_start    ;must be declared for linker(ld)
	
_start:				;tells linker entry point
	mov edx, len    ;message length
	mov ecx, msg	;message to write
	mov ebx, 1		;file descriptor(stdout)
	mov eax, 4		;system call number(sys_write)
	int 0x80		;call kernel
	
	mov eax, 1		;system call number(sys_exit)
	int 0x80		;call kernel
	
section.data
msg db 'Hello, world!', 0xa	;string to be printed
len equ $ - msg				;length of the string
```

**在NASM中编译和链接汇编程序**：

*前提首先要下载nasm以及ld*

步骤：

- 将文件存为.asm后缀
- 确保中断在.asm目录下
- 输入`nasm -f elf hello.asm`
- 创建hello.o程序目标文件
- 要链接目标文件并创建为hello的可执行文件，输入`ld -m elf_i386 -s -o hello hello.o`
- 通过输入`./hello`执行程序

将section换成segment也可运行成功

## 5. 内存段

​	分段内存模型将系统内存划分为由位于段寄存器中的指针引用的独立段组。 每个段用于包含特定类型的数据。 其中一个段用于包含指令代码，另一段用于存储数据元素，第三个段用于保存程序堆栈。

我们可以将各种内存段指定为:

- **数据段** − 它由 **.data** 部分和 **.bss** 表示。.data 部分用于声明内存区域，其中为程序存储数据元素。 该部分在数据元素声明后无法扩展，并且在整个程序中保持静态。

  .bss 部分也是一个静态内存部分，其中包含稍后在程序中声明的数据的缓冲区。 该缓冲存储器被零填充。

- **代码段** − 它由 **.text** 部分表示。 这定义了内存中存储指令代码的区域。 这也是一个固定区域。

- **堆栈** − 该段包含传递给程序内的函数和过程的数据值。

# 6. 寄存器

​	处理器操作主要涉及处理数据，该数据可以存储在存储器中并从存储器中访问。然鹅，从内存中读取数据很慢，因为这个过程涉及到通过控制总线发送数据请求并进入内存存储单元并通过通道获取数据，因此速度很慢。

​	为了加速处理器操作，处理器包含一些内部存储器存储位置，称为**寄存器**。存储器存储数据元素以进行处理，而无需访问内存。处理器芯片中设置了有限数量的寄存器。

IA-32架构中由10个32位和6个16位处理器寄存器。寄存器分为三类：

1. 通用寄存器

   - 数据寄存器：四个，用于算数、逻辑和其他运算。

     ​	可通过三种方式使用：

     - 作为完整的32位数据寄存器：EAX EBX ECX EDX
     - 下半部分可用作16位数据寄存器：AX BX CX DX
     - 上述16位寄存器上半部分和下半部分可用作8位寄存器：AH AL BH BL CH CL DH DL

     ​	特殊用途寄存器：

     1. **AX作为主累加器**：存在EAX/AX/AL
     2. **BX被称为基址寄存器**，可用于索引寻址
     3. **CX被称作计数寄存器**：用于存储迭代操作中的循环计数
     4. **DX被称作数据寄存器**：还用于输入/输出操作，AX与DX一起使用

   - 指针寄存器：32位EIP、ESP和EBP寄存器以及相应的16位右部分IP、SP和BP。

     - **指令指针（IP）**：16位IP寄存器存储下一条要执行的指令的偏移地址。 IP 与 CS 寄存器（如 CS:IP）关联给出了代码段中当前指令的完整地址。
     - **堆栈指针（SP）** − 16 位 SP 寄存器提供程序堆栈内的偏移值。 SP 与 SS 寄存器 (SS:SP) 相关，指的是程序堆栈中数据或地址的当前位置。
     - **基址指针（BP）** − 16 位 BP 寄存器主要帮助引用传递给子程序的**参数变量**。 SS寄存器中的地址与BP中的偏移量相结合，得到参数的位置（如SS:BP)。 *BP还可以与DI、SI组合作为基址寄存器进行特殊寻址*。

   - 索引寄存器:ESI 和 EDI 及其 16 位最右边部分。 SI和DI用于索引寻址，有时用于加法和减法。 
     - **来源索引 (SI)** +minus; 它用作字符串操作的源索引。
     - **目的地索引 (DI)** − 它用作字符串操作的目标索引。

2. 控制寄存器:32位**指令指针寄存器和32位标志寄存器**组合起来被视为控制寄存器。

   常见的标志位是:

   - **溢出标志(OF)** − 表示有符号算术运算后数据的高位（最左位）溢出。
   - **方向标志 (DF)** − 它确定移动或比较字符串数据的左或右方向。 当DF值为0时，字符串操作采取从左到右的方向，当该值设置为1时，字符串操作采取从右到左的方向。
   - **中断标志（IF）** − 它决定是否忽略或处理键盘输入等外部中断。 当该值为 0 时禁用外部中断，当设置为 1 时启用中断。
   - **陷阱标志 (TF)** − 它允许将处理器的操作设置为单步模式。 我们使用的 DEBUG 程序设置了陷阱标志，因此我们可以一次单步执行一条指令。
   - **符号标志（SF）** − 它显示算术运算结果的符号。 该标志是根据算术运算之后的数据项的符号来设置的。 符号由最左边位的高位表示。 正结果将 SF 的值清除为 0，负结果将其设置为 1。
   - **零标志 (ZF)** − 它表示算术或比较运算的结果。 非零结果将零标志清除为 0，零结果将其设置为 1。
   - **辅助进位标志 (AF)** − 它包含算术运算后从位 3 到位 4 的进位； 用于专门的算术。 当 1 字节算术运算导致从位 3 进位到位 4 时，AF 被置位。
   - **奇偶校验标志 (PF)** − 表示算术运算结果中1位的总数。 偶数个 1 位将奇偶校验标志清除为 0，奇数个 1 位将奇偶校验标志设置为 1。
   - **进位标志（CF）** − 它包含算术运算后从高位（最左边）进位 0 或 1。 它还存储*shift*或*rotate*操作的最后一位的内容。

   下表表示16位Flags寄存器中标志位的位置:

   | 标志位: |      |      |      |      | O    | D    | I    | T    | S    | Z    |      | A    |      | P    |      | C    |
   | :-----: | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | Bit no: | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |

3. 段寄存器

   段是程序中定义的用于包含数据、代码和堆栈的特定区域。 主要分为三个部分

   - **代码段** − 它包含所有要执行的指令。 16位代码段寄存器或**CS寄存器**存储代码段的起始地址。
   - **数据段** − 它包含数据、常量和工作区。 16位数据段寄存器或**DS寄存器**存储数据段的起始地址。
   - **堆栈段** − 它包含过程或子例程的数据和返回地址。 它被实现为"堆栈"数据结构。 堆栈段寄存器或**SS寄存器**存储堆栈的起始地址。

   除了 DS、CS 和 SS 寄存器外，还有其他额外段寄存器 :**ES（额外段）、FS 和 GS**，它们提供额外的段来存储数据。

   在汇编编程中，程序需要访问内存位置。 段内的所有内存位置都相对于段的起始地址。 段从可被 16 或十六进制 10 整除的地址开始。因此，**所有此类内存地址中最右边的十六进制数字都是 0，通常不存储在段寄存器中。**

   段寄存器存储段的起始地址。 为了获得段内数据或指令的准确位置，需要偏移值（或位移）。 为了引用段中的任何内存位置，处理器将段寄存器中的段地址与该位置的偏移值组合起来。

**示例**：

```assembly
section	.text
   global _start	 ;must be declared for linker (gcc)
	
_start:	         ;tell linker entry point
   mov	edx,len  ;message length
   mov	ecx,msg  ;message to write
   mov	ebx,1    ;file descriptor (stdout)
   mov	eax,4    ;system call number (sys_write)
   int	0x80     ;call kernel
	
   mov	edx,9    ;message length
   mov	ecx,s2   ;message to write
   mov	ebx,1    ;file descriptor (stdout)
   mov	eax,4    ;system call number (sys_write)
   int	0x80     ;call kernel
	
   mov	eax,1    ;system call number (sys_exit)
   int	0x80     ;call kernel
	
section	.data
msg db 'Displaying 9 stars',0xa ;a message
len equ $ - msg  ;length of message
s2 times 9 db '*'
```

展示结果

```
Displaying 9 stars
*********
```


## 哈希表（字典）

​	**哈希表，又称散列表，类似于字典，它通过建立键key与值value之间的映射，实现高效的元素查询。**

### 1、哈希表的常用操作

​	哈希表的常见操作包括：初始化、查询操作、添加键值对和删除键值对。示例代码如下：

```c++
// 初始化
unordered_map<int, string> map;

// 添加操作
map[123456] = "小哈";

// 查询操作
string name = map[123456];

// 删除操作
map.erase(123456);
```

### 2、哈希表的遍历

​	哈希表有三种常见的遍历方式：遍历键值对、遍历键和遍历值。如下：

```c++
for (auto kv : map) {
    cout << kv.first << kv.second << endl;
}
for (auto iter = map.begin(); iter != map.end(); iter++) {
    cout << iter->first << iter->second << endl;
}
```

基本思想：将较大的输入空间映射到较小的输出空间。使用哈希函数，找到key对应的存储单位。一般情况是求余（%）操作。但是会出现哈希冲突现象，解决方法有哈希表扩容，但是为了防止频繁扩容操作，一般系统会分配较大空间。此时出现了一个新的概念，负载因子，*用于衡量哈希冲突的严重程度*，定义为哈希表的元素数量除以桶数量，如果超过0.75，系统则会自动给哈希表扩容至原来的2倍。

### 3、解决哈希冲突

1. 链式地址

   将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。对应的三种操作的操作方法也有所改变。

   缺点：

   - 占用空间大
   - 时间效率低

   ***使用动态数组来代替链表，从而简化代码***

2. 开放寻址

   ​	不引入额外的数据结构，减少内存使用，而是通过“多次探测”来解决冲突，而多次探测分为三种探测方法：

   - **线性探测**：若发生冲突，则顺次向后寻找空桶。

     ​	缺点：容易发生聚集现象，并且不能直接进行删除操作，会产生空桶，导致误判。

     ​	解决：使用懒删除机制，不直接从哈希表中移除元素，而是利用一个常量`TOMESTONE`来标记这个桶，在该机制下，`None`和`TOMESTONE`都代表空桶，但是`TOMESTONE`要继续探测。

   - **平方探测**：跳过步数为探测次数的平方：1，4，9...

   - **多次哈希**：不易产生聚集，但是会存在额外多余的计算量

     

## 树

### 1、二叉树

​	**二叉树**是一种非线性的数据结构，代表祖先与后代之间的派生关系，体现了“一分为二”的分治逻辑。

​	***个人见解**：首先，树这种数据结构归根结底是一种数据存储方式，因此它在根本层面上会体现在数据的处理上，与常规数据结构不同的是，比如**数组**强调的是数据的一个顺序存储，是在存储方式上的一个强调，再比如**哈希表**，强调的是数据一对一的映射；而对于**树**来说，强调的可能是数据一对多的一种模式，具有上下层的关系，比如现实生活中的公司上下级关系等等，但其实感觉现实生活中更常见的模式是图，因此对于树的应用以及理解还有待提高和学习。*

### **2、 二叉树常见术语**

- 根节点
- 叶节点
- 边
- 节点所在的层：从顶层至底层递增，顶层层为1
- 节点的度：节点的子节点数量，度的取值范围为0、1、2
- 二叉树的高度：根节点到最远叶节点经过的边数
- 节点的深度：从该节点到根节点经过的边数
- 节点的高度：从该节点到最远叶节点经过的边数

### **3、 常见二叉树类型**

1. **完美二叉树（满二叉树）**：所有层节点均被填满，节点总数与层数呈现标准的指数级关系，反映了自然界常见的细胞分裂现象。
2. **完全二叉树**：除了底层之外其余均被填满，且底层从左至右依次填充。完美二叉树也是一颗完全二叉树。
3. **完满二叉树**：除了叶节点外，其余所有节点度均为2
4. **平衡二叉树**：任意节点的左子树和右子树的高度之差绝对值不超过1.这样的定义也是平衡二叉树递归构建的方法。

### **4、 二叉树的退化**

​	与完美二叉树对应的另一种极端情况，节点全部偏向一侧，退化成链表。

### **5、 二叉树的遍历**

​	因为树的存储结构并不是一个顺序的情况，因此对于树的遍历只能通过树的指针来遍历。二叉树的常见遍历方式有：层序遍历，前序遍历、中序遍历以及后序遍历等。

- 层序遍历（又称广度优先遍历）BFS：因为思路与队列的先进先出思路类似，因此广度优先遍历的实现是依靠队列来实现的。

```c++
class BFS {
    vector<int> levelOrder (TreeNode* root) {
        queue<TreeNode* node> Queue;
        Queue.push(root);
        // 初始化数组，用于保存遍历序列
        vector<int> vec;
        while (!Queue.empty()) {
            TreeNode* node = Queue.front();
            Queue.pop();
            vec.push_back(node->val);
            if (node->left != nullptr) Queue.push(node->left);
            if (node->right != nullptr) Queue.push(node->right);
        }
        return vec;
    }
};
```



- 先序、中序以及后序遍历：都属于**深度优先遍历**DFS，思路为像是围绕二叉树的外围走一圈，采用递归的思想，根据对节点的操作位置分为先序中序以及后序，

```c++
class DFS {
    vector<int> vec_pre;
    vector<int> vec_in;
    vector<int> vec_post;
    void preOrder (TreeNode* node) {
        if (node == nullptr) return;
        vec_pre.push_back(node->val);
        preOrder(node->left);
        preOrder(node->right);
    }
    
    void inOrder (TreeNode* node) {
        if (node == nullptr) return;
        inOrder(node->left);
        vec_in.push_back(node->val);
        inOrder(node->right);
    }
    
    void postOrder (TreeNode* node) {
        if (node == nullptr) return;
        postOrder(node->left);
        postOrder(node->right);
        vec_post.push_back(node->val);
    }
    
    // 同样可以利用先进后出的思想使用栈来以迭代的思想实现深度优先遍历
};
```

### 6、二叉树的数组表示

​	***重点是父节点和子节点的位置关系，位置的倍数关系，即若某节点的索引为i，则该节点的左子节点索引为2i+1，右子节点索引为2i+2***

​	tip：完全二叉树非常适合使用数组来表示，因为所有None一定会出现再层序遍历的末尾。

**优点**：

- 数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快
- 不需要存储指针，比较节省空间
- 允许随机访问节点

**缺点**：

- 数组存储需要连续内存空间，因此不适合存储数据量过大的树
- 增删节点需要通过数组的插入与删除操作实现，效率过低
- 当二叉树存在大量Node时，空间利用率低

### 7、二叉搜索树

​	左子树小于中间节点，右子树大于中间节点，因此对于二叉搜索树的中序遍历

### 8、AVL树（二叉平衡树）

​	防止二叉树退化为链表，保证每个节点的左右子树高度差不超过1。

**数据结构**：因为对每个节点的高度存在要求，并且根据其高度对树进行调整，因此数据结构多出一个特征，即**节点的高度**。注意，叶节点的高度为0，而空节点的高度为-1.

相关概念：

- **节点平衡因子**：节点左子树的高度减去右子树的高度，同时规定空节点的平衡因子为0。取值为[-1,1]

- **AVL树的旋转**：基本操作为**左旋**以及**右旋**这两种基本失衡情况为对称的情形。

  - **右旋**：该节点平衡因子>1，即为左偏树，操作为对于三个节点的操作，本节点node、左子节点child，左子节点的右子节点grandchild，使child右子节点指向node，node的左子节点指向grandchild。

  ```c++
  TreeNode* rightRotate (TreeNode* node) {
      TreeNode* child = node->left;
      TreeNode* grandchild = node->right;
      child->right = node;
      node->left = grandchild;
      // 因为发生变化的有child和node节点，所以更新这两个节点高度
      updataHeight(child);
      uodataHeight(node);
      return child;
  }
  ```

  

  - **左旋**：与右旋是对称的情况，该节点平衡因子<1，即为右偏树，操作为对于三个节点的操作，本节点node、右子节点child，右子节点的左子节点grandchild，使child左子节点指向node，node的右子节点指向grandchild。

  ```c++
  TreeNode* leftRotate (TreeNode* node) {
      TreeNode* child = node->right;
      TreeNode* grandchild = node->left;
      child->left = node;
      node->right = grandchild;
      // 因为发生变化的有child和node节点，所以更新这两个节点高度
      updataHeight(child);
      uodataHeight(node);
      return child;
  }
  ```

- **AVL树的旋转情况选择**：除了跟该节点的平衡因子有关之外，还与子节点的平衡因子有关

| 节点的平衡因子 | 子节点的平衡因子 | 对应操作                     |
| -------------- | ---------------- | ---------------------------- |
| >1             | >=0              | 右旋                         |
| >1             | <0               | 先对子节点左旋再对本节点右旋 |
| <1             | <=0              | 左旋                         |
| <1             | >0               | 先对子节点右旋再对本节点左旋 |

- **AVL树常用操作**：
  1. 插入节点：第一步采用二叉搜索树的插入操作找到该插入的位置，第二步对根节点进行调整，即旋转操作。
  2. 删除节点：同样第一步借助二叉搜索树的删除操作进行删除，第二步在其基础上再进行旋转操作。

*Tip: 红黑树也是一种常见的二叉搜索树，相较于AVL树，其平衡条件更为宽松，旋转操作更少，节点增删操作的平均效率更高。*

